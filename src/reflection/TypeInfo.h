//
// Created by Magnitola on 14.10.2025.
//

#pragma once
#include <string>
#include <unordered_map>
#include <utility>
#include <vector>

#include "ConstructorInfo.h"
#include "FieldInfo.h"
#include "MethodInfo.h"


/**
 * Meta-information about a type for reflection system.
 *
 * Stores complete type metadata including fields, methods, constructors, and inheritance hierarchy.
 *
 * @note This class is populated by the Reflector and should not be constructed manually.
 */
class TypeInfo {
public:
    using FieldMap = std::unordered_map<std::string, FieldInfo>;
    using BaseClasses = std::vector<const TypeInfo *>;
    using MethodMap = std::unordered_map<std::string, MethodInfo>;
    using Constructors = std::vector<ConstructorInfo>;

    explicit TypeInfo(std::string className) : className_(std::move(className)) {
    }

    /**
     * @return Type name generated by the compiler
     */
    const std::string &getClassName() const { return className_; }

    /**
     * @return Type fields
     */
    const FieldMap &getFields() const { return fields_; }

    /**
     * @return Type base classes
     */
    const BaseClasses &getBaseClasses() const { return baseClasses_; }

    /**
     * @return Type methods
     */
    const MethodMap &getMethods() const { return methodMap_; }

    /**
     * @return Type constructors
     */
    const Constructors &getConstructors() const { return constructors_; }

    /**
     * @return Type fields, including those inherited from the base types
     */
    FieldMap getAllFields() const;

    /**
     * @return All hierarchy
     */
    BaseClasses getAllBaseClasses() const;

    /**
     * @return Type methods, including those inherited from the base types
     */
    MethodMap getAllMethods() const;

    /**
     * Construct object using default (parameterless) constructor
     * @return Raw pointer to constructed object
     * @warning Return nullptr if no suitable constructor found
     * @warning Caller owns the memory and must manage its lifetime
     * @note For types without default constructor, use construct(args)
     */
    void *construct();

    /**
     * Construct object with specified parameters
     * @param args Constructor arguments
     * @return Raw pointer to constructed object
     * @warning Return nullptr if no suitable constructor found
     * @warning Caller owns the memory and must manage its lifetime
     */
    void *construct(const std::vector<std::any> &args);

    /**
     * @param fieldName field name
     * @return contained field info
     * @warning return nullptr if field not exist
     */
    const FieldInfo *getField(const std::string &fieldName) const;

    /**
     * @param methodName method name
     * @return contained method info
     * @warning return nullptr if method not exist
     */
    const MethodInfo *getMethod(const std::string &methodName) const;

private:
    void collectFieldsRecursive(FieldMap &allFields) const;

    void collectBaseClassesRecursive(BaseClasses &allBaseClasses) const;

    void collectMethodsRecursive(MethodMap &allMethods) const;

    void addField(const FieldInfo &field);

    void addBaseClass(const TypeInfo *baseClass);

    void addMethod(const MethodInfo &method);

    void addConstructor(const ConstructorInfo &constructor);

    ConstructorInfo *findConstructor(const std::vector<std::any> &args);

    std::string className_;
    FieldMap fields_;
    BaseClasses baseClasses_;
    MethodMap methodMap_;
    Constructors constructors_;

    friend class Reflector;
};
